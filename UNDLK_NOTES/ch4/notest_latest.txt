interrupts are divided into 
•Synchronous produced by the CPU control unit while executing instructions.The control unit issues them only after terminating the execution of an instruction.
•Asynchronous generated by other hardware devices at arbitrary times with respect to the CPU clock signals. 
Intel 80x86 manuals call synchronous and asynchronous interrupts as exceptions and interrupts

Interrupts(sync) raised by interval timers and I/O devices;ex keystroke from a user 
Exceptions(async) are caused by programming errors or by anomalous conditions that must be handled by the kernel.
Programming errors:the kernel handles by delivering to the current process one of the signals familiar to every Unix programmer.
Anomalous conditions:the kernel performs all the steps needed to recover from the anomalous condition, such as a page fault or a request (via an int instruction) for a kernel service.

The Role of Interrupt Signals
When an interrupt occurs,the CPU must stop what it's doing and switch to new activity;by saving the current value of the PC (eip & cs reg) in the Kernel Mode stack and by placing an address related to the interrupt type into the PC. 

there is difference between interrupt handling and process switching: the code executed by an interrupt is not a process but a kernel control path that runs on context of the process that was running when the interrupt occurred.Interrupt handler is lighter than a process (it has less context and requires less time to set up or tear down). 

Interrupt Hnadling must satisfy satisfy the following constraints:

1 Making interrupts short and real time (BH and TH)
Interrupts can come at any time Thus kernel needs to get the interrupt out of the way as soon as possible and defer as much processing as it can.(To BHs)

For eg,A block of data arrived on a network line.
The hardware interrupts the kernel
it simply marks the presence of data
gives the processor back to whatever was running before
Does rest of the processing(like moving the data into a buffer where its recipient process can find it and restarting the proces)later.
Activities that are needed to be performed for interrupt are divided in:
a top half that the kernel executes right away 
and a bottom half that is left for later.
A queue pointing to all BHs waiting to be executed kernel pulls them off the queue to execute them at particular points in processing.

2 Nestablility in interrupt kernel control paths

Interrupts can come at any time, the kernel might be handling one of them while 
another(of diff type)occurs. This should be allowed as keeps the I/O devices busy.
The interrupt handlers must be coded so that the corresponding kernel control 
paths can be executed in a nested manner.
When the last kernel control path terminates, the kernel must be able to resume execution of the interrupted process or switch to another process if the interrupt signal has caused a rescheduling activity. 

3 Limited use of critical regions requiring interrupts to be disabled
Although the kernel may accept a new interrupt signal while handling a previous one some critical regoins may disable interrupts
in particular the interrupt handlers, should run most of the time with the interrupts enabled

Classification

Interrupts:
1 Maskable : Sent to INTR pin.They can be disabled by clearing the IF flag of the eflags register.eg IRQs issued by I/O devices
2 Nonmaskable :Sent to the NMI pin.Only a few critical events,eg hardware failures, give rise to them.

Exceptions:

1 Processor-detected exceptions (Faults , traps and Aborts)
Generated on CPU finding anomalous condition while executing an instruction. divided into three groups,depending on the value of the eip saved on the Kernel Mode stack when control unit raises them 
 	a Faults
eip is the address of the instruction that caused the fault, and same instruction can be resumed when the exception handler terminates. whenever the handler is able to correct the anomalous condition that caused the exception. 
	b Traps
eip is the address of the instruction that should be executed after the one that caused the trap. A trap is triggered only when there is no need to reexecute the instruction that terminated.
use of traps is for debugging purposes:eg to notify the debugger that a specific instruction has been executed (eg breakpoint has been reached within a program). Once the user has examined the data provided by the debugger,execution of the debugged program resume starting from the next instruction. 
	c Aborts
A serious error; the control unit is in trouble,and it may be unable to store a meaningful value in the eip.May be caused by hardware failures or by invalid values in system tables. The inte rrupt signal sent by the control unit is an emergency signal used to switch control to the corresponding abort exception handler. This handler has no choice but to force the affected process to terminate.

2 Programmed exceptions
Occur at the request of the programmer.Triggered by: 1)int or int3 instructions; 2)the into (check for overflow) and bound (check on address bound) instructions when the condition they are checking is not true.
Programmed exceptions are handled by the control unit as traps; they are often called software interrupts. Such exceptions have two common uses: to implement system calls, and to notify a debugger of a specific event

Interrupt / Exception vectores

Each intr or excptn has a 8bit unsigned identifier from 0 to 255 called vector
For nonmaskable interrupts and exceptions are fixed
for maskable interrupts can be altered by programming Interrupt Controller

Linux uses the following vectors: 
•0 to 31 : exceptions and nonmaskable interrupts. 
•32 to 47: maskable interrupts, that is, to interrupts caused by IRQs. 
•remaining from 48 to 255 may be used to identify software interrupts.Linux uses one of them, namely the 128 or 0x80 vector to implement system calls. When an int 0x80 Assembly instruction is executed by a process in User Mode, the CPU switches into Kernel Mode and starts executing the system_call( ) kernel function


IRQ and Interrupts

Each hw device controller capable of issuing interrupt requests has an op line designated as an IRQ (Interrupt ReQuest).All IRQ lines are connected to the input pins of a hardware circuit called the Interrupt Controller, which performs the following actions: 
1.Monitors the IRQ lines, checking for raised signals. 
2.If a raised signal occurs on an IRQ line: 
a.Converts the raised signal into a corresponding vector. 
b.Store vector in an Itr Contrlr I/O port so thatCPU can read it via the data bus.
c.Sends a raised signal to the processor INTR pin—that is, issues an interrupt.
d.Waits until the CPU acks the intr signal by writing into one of 
the Programmable Interrupt Controllers (PIC) I/O ports;when wait ends clears the INTR line.
3.Goes back to step 1. 
The IRQ lines are sequentially numbered starting from 0; thus, the first IRQ line is denoted as IRQ0. Intel's default vector with IRQn is n+32
the mapping between IRQs and vectors can be modified by issuing suitable I/O instructions to the Interrupt Controller ports. 
Figure 4-1 illustrates a typical connection "in cascade" of two Intel 8259A PICs that can handle up to 15 different IRQ input lines.
Other lines not shown in the figure connect the PICs to the bus: in particular, bidirectional lines D0-D7 connect the I/O port to the data bus, while
another input line is connected to the control bus and is used for receiving acknowledgment signals from the CPU. 
Since the number of available IRQ lines is limited, it may be necessary to share the same line among several different I/O devices. When this occurs, all the devices connected to the same line will have to be polled sequentially by the software interrupt handler in order to determine which of them has issued an interrupt request.

FIGURE 4-1

Each IRQ line can be selectively disabled. Thus, the PIC can be programmed to disable IRQs. Disabled interrupts are not lost; the PIC sends them to the CPU as soon as they are enabled again. This feature is used by most interrupt handlers, since it allows them to process IRQs of the same type serially.Selective enabling/disabling of IRQs is not the same as global masking/unmasking of maskable interrupts. When the IF flag of the eflags register is clear, any maskable interrupt issued by the PIC is simply ignored by the CPU. The cli and sti Assembly instructions, respectively, clear and set that flag. 

Exceptions The Intel 80x86 microprocessors issue roughly 20 different exceptions.the CPU control unit also generates a hardware error code and pushes it in the Kernel Mode stack before starting the exception handler. 
The following list gives the vector, the name, the type, and a brief description of the exceptions found in a Pentium model.


0 - "Divide error" (fault) Raised when a program tries to divide by 0.
1- "Debug" (trap or fault) Raised when the T flag of eflags is set (quite useful to implement step-by-step execution of a debugged program) or when the address of an instruction or operand falls within the range of an active debug register
2 - Not used Reserved for nonmaskable interrupt
3 - "Breakpoint" (trap) Caused by an int3 (breakpoint) instruction (usually inserted by a debugger). 
4 - "Overflow" (trap) An into (check for overflow) instruction has been executed when the OF (overflow) flag of eflags is set. 
5 - "Bounds check" (fault) A bound (check on address bound) instruction has been executed with the operand outside of the valid address bounds. 
6 - "Invalid opcode" (fault) The CPU execution unit has detected an invl opcode
7 - "Device not available" (fault) An ESCAPE or MMX instruction has been executed with the TS flag of cr0 set 
8 - "Double fault" (abort) Normally, when the CPU detects an exception while trying to call the handler for a prior exception, the two exceptions can be handled serially. In a few cases, however, the processor cannot handle them serially, hence it raises this exception. 
9 - "Coprocessor segment overrun" (abort) Problems with the external mathematical coprocessor (applies only to old 80386 microprocessors). 
10 - "Invalid TSS" (fault) The CPU has attempted a context switch to a process having an invalid Task State Segment. 
11 - "Segment not present" (fault) A reference was made to a segment not present in memory (Segment-Present flag of Segment Descriptor was cleared). 
12 - "Stack segment" (fault) The instruction attempted to exceed the stack segment limit, or the segment identified by ss is not present in memory. 
13 - "General protection" (fault)One of the protection rules in the protected mode of the Intel 80x86 has been violated. 
14 - "Page fault" (fault) The addressed page is not present in memory, the corresponding page table entry is null, or a violation of the paging protection mechanism has occurred. 
15 - Reserved by Intel
16 - "Floating point error" (fault)The floating point unit integrated into the CPU chip has signaled an error condition, such as numeric overflow or division by 0. 
17 - "Alignment check" (fault)The address of an operand is not correctly aligned (for instance, the address of a long integer is not a multiple of 4). 
18 to 31 These values are reserved by Intel for future development. 

Table 4-1

4.2.4 Interrupt Descriptor Table 
System table Interrupt Descriptor Table (IDT) associates each interrupt or exception vector with the address of the corresponding interrupt or exception handler. The IDT must be properly initialized before the kernel enables interrupts. format similar GDT and of the LDTs: each entry corresponds to an in terrupt or an exception vector and consists of an 8-byte descriptor. Thus, a maximum of 256x 8=2048 bytes 
The idtr CPU register allows the IDT to be located anywhere in memory:both the IDT base physical address and its limit (maximum length). It must be initialized before enabling interrupts by using the lidt assembly language instruction. The IDT may include three types of descriptors; Figure 4-2 illustrates the meaning of the 64 bits included in each of them.Type field bits 40-43 identifies the descriptor type. 

Figure 4-2

Task gate Includes the TSS selector of the process that must replace the current one when an interrupt signal occurs. Linux does not use task gates. 
Interrupt gate Includes the Segment Selector and the offset inside the segment of an interrupt or exception handler. While transferring control to the proper segment, the processor clears the IF flag, thus disabling further maskable interrupts. 
Trap gate Similar to an interrupt gate, except that while transferring control to the proper segment, the processor does not modify the IF flag. 
Linux uses interrupt gates to handle interrupts and trap gates to handle exceptions. 

4.2.5 Hardware Handling of Interrupts and Exceptions 

how the CPU control unit handles interrupts and exceptions. We assume that the kernel has been initialized and thus the CPU is operating in protected mode. After executing an instruction, the cs and eip pair of registers contain the logical address of the next instruction to be executed. Before dealing with that instruction, the control unit checks whether an interrupt or an exception has occurred while it executed the previous instruction. If one occurred, the control unit: 
1.Determines the vector i associated with the interrupt or the exception. 
2.Reads the i th entry of the IDT referred by the idtr register (we assume the entry contains an interrupt or a trap gate). 
3.Gets the base address of the GDT from gdtr and looks in the GDT to read Segment Descriptor identified by the selector in the IDT entry. This descriptor specifies the base address of the segment that includes the interrupt or exception handler. 
4.Makes sure the interrupt was issued by an authorized source. First compares the Current Privilege Level (CPL), which is stored in the two LSBs of cs, with the Descriptor Privilege Level (DPL) of the Segment Descriptor included in the GDT. Raises a "General protection" exception if CPL is lower than DPL, because the interrupt handler cannot have a lower privilege (more PL value)than the program that caused the interrupt. For programmed exceptions, makes a further security check: compares the CPL with the DPL of the gate descriptor included in the IDT and raises a "General protection" exception if the DPL is lower than the CPL. This last check makes it possible to prevent access by user applications to specific trap or interrupt gates. 
5.Checks whether a change of privilege level is taking place, that is, if CPL is different from the selected Segment Descriptor's DPL. If so, the control unit must start using the stack that is associated with the new privilege level. It does this by performing the following steps: 
a.Reads the tr register to access the TSS segment of the current process. 
b.Loads the ss and esp registers with the proper values for the stack segment and stack pointer relative to the new privilege level. These values are found in the TSS
c.In the new stack, saves the previous values of ss and esp, which define the logical address of the stack associated with the old privilege level. 
6.If a fault has occurred, loads cs and eip with the logical address of the instruction that caused the exception so that it can be executed again. 
7.Saves the contents of eflags, cs, and eip in the stack. 
8.If the exception carries a hardware error code, saves it on the stack. 
9.Loads cs and eip, respectively, with the Segment Selector and the Offset fields of the Gate Descriptor stored in the i th entry of the IDT. Thesevalues define the logical address of the first instruction of the interrupt or exception handler. The last step performed by the control unit isequivalent to a jump to the interrupt or exception handler.

In other words, the instruction processed by the control unit after dealing with theinterrupt signal is the first instruction of the selected handler. After the interrupt or exception has been processed, the corresponding handlermust relinquish control to the interrupted process by issuing the iret
 instruction, which forces the cu to:

1.Load the cs, eip, and eflags registers with the values saved on the stack. If a hw err code has been pushed in the stack on top of the eip contents, it must be popped before executing iret. 
2.Check whether the CPL of the handler is equal to the value contained in the two least significant bits of cs If so, iret concludes execution; otherwise, go to the next step. 
3.Load the ss and esp registers from the stack, and hence return to the stack associated with the old privilege level. 
4.Examine the contents of the ds, es, fs, and gs segment registers: if any of them contains a selector that refers to a Segment Descriptor whose DPL value is lower than CPL, clear the corresponding segment register. The control unit does this to forbid User Mode programs that run with a CPL equal to 3 from making use of segment registers previously used by kernel routines (with a DPL equal to 0). If these registers were not cleared, malicious User Mode programs could exploit them to access the kernel address space

4.3 Nested Execution of Exception and Interrupt Handlers 
A kernel control path consists of the sequence of instructions executed in Kernel Mode to handle an interrupt or an exception. When a process issues a system call request, for instance, the first instructions of the corresponding kernel control path are those that save the content of the registers in the Kernel Mode stack, while the last instructions are those that restore the content of the registers and put the CPU back into User Mode. 

Assuming that the kernel is bug-free, most exceptions can occur only while the CPU is in User Mode. Indeed, they are either caused by programming errors or triggered by debuggers. However, the "Page fault" exception may occur in Kernel Mode.While handling such an exception, the kernel may suspend the current process and replace it with another one until the requested page is available.The kernel control path that handles the page fault exception will resume execution as soon as the process gets the processor again. Since the "Page fault" exception handler never gives rise to further exceptions, at most two kernel control paths associated with exceptions may be stacked, one on top of the other. 
In contrast to exceptions, interrupts issued by I/O devices do not refer to data structures specific to the current process, although the kernel control paths that handle them run on behalf of that process. As a matter of fact, it is impossible to predict which process will be currently running when a given interrupt occurs. Linux design does not allow process switching while the CPU is executing a kernel control path associated with an interrupt. However, such kernelcontrol paths may be arbitrarily nested: an interrupt handler may be interrupted by another interrupt handler and so on. An interrupt handler may also defer an exception handler. Conversely, an exception handler never defers an interrupt handler. The only exception that can be triggered in Kernel Mode is the "Page fault" one just described. But interrupt handlers never perform operations that could induce page faults and thus, potentially, process switching. 
Linux interleaves kernel control paths for two major reasons:
•To improve the throughput of programmable interrupt controllers and device controllers. Assume that a device controller issues a signal on an IRQ line:thePIC transforms it into an INTR request, and then both the PIC and the device controller remain blocked until the PIC receives an acknowledgment from the CPU. Thanks to kernel control path interleaving, the kernel is able to send the acknowledgment even when it is handling a previous interrupt. 
•To implement an interrupt model without priority levels. Since each interrupt handler may be deferred by another one, there is no need to establishpredefined priorities among hardware devices. This simplifies the kernel code and improves its portability

4.4 Initializing the Interrupt Descriptor Table 
The int instruction allows a User Mode process to issue an interrupt signal having an arbitrary vector ranging from to 255. The initialization of the IDT must thus be done carefully, in order to block illegal interrupts and exceptions simulated by User Mode processes via int instructions. This can be
 achieved by setting the DPL field of the Interrupt or Trap Gate Descriptor to 0. In a few cases, however, a User Mode process must be able to issue a programmed exception. To allow this, it is sufficient to set the DPL field of the corresponding Interrupt or Trap Gate Descriptors to 3;

Interrupt gate :An Intel intr gate that cannot be accessed by a User Mode process (the gate's DPL field is equal to 0). All Linux intr handlers are activated by means of interrupt gates, and all are restricted to Kernel Mode. 
System gate:An Intel trap gate that can be accessed by a User Mode process (the gate's DPL field is equal to 3). The four Linux exception handlers associated with the vectors 3, 4, 5, and 128 are activated by means of system gates, so the four Assembly instructions int3, into, bound, and int 0x80 can be issued in User Mode. 
Trap gate:An Intel trap gate that cannot be accessed by a User Mode process (the gate's DPL field is equal to 0). All Linux exception handlers, except the four described in the previous paragraph, are activated by means of trap gates. 

The following functions are used to insert gates in the IDT: 
set_intr_gate(n,addr)
Inserts an interrupt gate in the nth IDT entry. The Segment Selector inside the gate is set to the kernel code's Segment Selector. The Offset field is set to addr, which is the address of the interrupt handler. The DPL field is set to 0. 
set_system_gate(n,addr)
Same exceppt trap gate and The DPL field is set to 3. 
set_trap_gate(n,addr)
Similar to the previous function, except that the DPL field is set to 0

4.4.2 Preliminary Initialization of the IDT
During kernel initialization, the setup_idt( ) assembly language function starts by filling all 256 entries of idt_table with the same interrupt gate, which refers to the ignore_int( ) interrupt handler: 

The ignore_int( )interrupt handler, which is in assembly language, may be viewed as a null handler that executes the following actions: 
1.Saves the content of some registers in the stack 
2.Invokes the printk( )function to print an "Unknown interrupt" system message 
3.Restores the register contents from the stack 
4.Executes an iret instruction to restart the interrupted program 
The ignore_int( )handler should never be executed: 
It denotes either a hardware problem (an I/O device is issuing unforeseen interrupts) or 
a kernel problem (an interrupt or exception is not being handled properly). 
Following this preliminary initialization, the kernel makes a second pass in the IDT to replace some of the null handlers with meaningful trapand interrupt handlers. 

4.5 Exception Handling 
Linux takes advantage of exceptions to achieve two quite different goals: 
•To send a signal to a process to notify an anomalous condition 
•To handle demand paging 
An example of the first use is if a process performs a division by 0. The CPU raises a "Divide error" exception, exception handler sends a SIGFPE to the current process, which will take the necessary steps to recover or (if no signal handler is set for that signal)abort. 
Exception handlers have a standard structure consisting of three parts: 
1.Save the contents of most registers in the Kernel Mode stack (this part is coded in Assembly language). 
2.Handle the exception by means of a high-level C function. 
3.Exit from the handler by means of the ret_from_exception( )function. 
In order to take advantage of exceptions, the IDT must be properly initialized with an exception handler function for each recognized exception. trap_init insterts the handlers—that is, the functions that handle the exceptions—into all IDT entries that refer to nonmaskable interrupts and exceptions. 
set_trap_gate(0,&divide_error); 
set_trap_gate(1,&debug); 
set_trap_gate(2,&nmi); 
set_system_gate(3,&int3); 
set_system_gate(4,&overflow); 
set_system_gate(5,&bounds); 
set_trap_gate(6,&invalid_op); 
set_trap_gate(7,&device_not_available); 
set_trap_gate(8,&double_fault); 
set_trap_gate(9,&coprocessor_segment_overrun); 
set_trap_gate(10,&invalid_TSS); 
set_trap_gate(11,&segment_not_present); 
set_trap_gate(12,&stack_segment); 
set_trap_gate(13,&general_protection); 
set_trap_gate(14,&page_fault); 
set_trap_gate(16,&coprocessor_error); 
set_trap_gate(17,&alignment_check); 
set_system_gate(0x80,&system_call); 

.5.1 Saving the Registers 
Each exception handler starts with the following Assembly instructions: handler_name
pushl $0 /* only for some exceptions */ 
If the exception does not need hardware error code on the stack than this pads the stack with a null
pushl $do_handler_name 
Address of the high-level C function is pushed on the stack
jmp error_code 
The Assembly fragment labeled as error_code is the same for all exception handlers except the one for the "Device not available" exception 
The code performs the following steps: 
1.Saves the registers that might be used by the high-level C function on the stack. 
2.Issues a cld instruction to clear the direction flag DF of eflags, thus making sure that autoincrements on the edi and esi registers will be used with string instructions. 
3.Copies the hardware error code saved in the stack at location esp+36 in eax. Stores in the same stack location value -1: , this value is used to separate 0x80(int) exceptions from other exceptions. 
4.Loads ecx with the address of the high-level do_handler_name(  )C function saved in the stack at location esp+32; writes the contents of esin that stack location. 
5.Loads the kernel data Segment Selector into the ds and es registers, then sets the ebx register to the address of the current process descriptor
6.Stores the parameters to be passed to the high-level C function on the stack, namely, the exception hardware error code and address of stack location where value of User Mode registers was saved. 
7.Invokes the high-level C function whose address is now stored in ecx

After the last step is executed, the invoked function will find on the top locations of the stack: 
•The return address of the instruction to be executed after the C function terminates 
•The stack address of the saved User Mode registers 
•The hardware error code

4.5.2 Returning from the Exception Handler 
When the C function that implements the exception handling terminates, control is transferred to the following assembly language fragment: 
addl $8, %esp 
pops the stack address of the saved UserMode registers and the hardware error code from the stack, 
jmp ret_from_exception 

4.5.3 Invoking the Exception Handler 
 Most of these functions done as follows: 
current->tss.error_code = error_code; 
store the hardware error code and the exception vector in the process descriptor of current
current->tss.trap_no = vector; 
force_sig(sig_number, current); 
 then send to that process a suitable signal. 
When the ret_from_exception( ) function is invoked, it checks if process has received a signal. If so, the signal will be handled either by the process's own signal handler (if it exists) or by the kernel;
Finally, the handler invokes either die_if_kernel( ) or die_if_no_fixup( ): 
•The die_if_kernel( ) function checks whether the exception occurred in Kernel Mode; in this ca
se, it invokes the die( ) function, which prints the contents of all CPU registers on the console and terminates the current process by invoking  do_exit( )
•The die_if_no_fixup( )function is similar, but before invoking die( )it checks whether the exception was due to an invalid argument of a system call: in the affirmative case, it uses a "fixup" approach, 
Two exceptions are exploited by the kernel 
•"Device not available": , this exception is used to defer loading the floating point registers until the last possible moment. 
•"Page fault": , this exception is used to defer allocating new page frames to the process until the last possible moment. 

4.6 Interrupt Handling 
exceptions are handled by sending signal to the  process that caused the exception. Process handles signal later.
Interrupts are async so they can arrive anytime even after the process that caused them has expired Furthermore, due to hardware limitations, several devices may share the same IRQ line. 
Thhus interrupt handler must be flexible enough to service several devices. In order to do this , several interrupt service routines(ISRs) can be associated with the same interrupt handler; each ISR is a function related to a single device sharing the IRQ line. Each ISR is executed to verify whether its device needs attention; if so, the ISR performs all the operations that need to be executed when the device raises an interrupt. ISRs should be short and real time.
since while an interrupt handler is running, the signals on the corresponding IRQ line are ignored. Most important, the process on behalf of which an interrupt handler is executed must always stay in the TASK_RUNNING state, or a system freeze could occur. Therefore, interrupt handlers cannot perform any blocking procedure such as I/O disk operations. So Linux divides the actions to be performed following an interrupt into three classes: 

Critical:eg. Ack to an interrupt to the PIC, reprogramming the PIC, or updating data structures accessed by both the device and the processor.can be executed quickly.Critical actions are executed within the interrupt handler immediately, with maskable interrupts DISABLED. 
Noncritical:eg updating structures that are accessed only by the processor These actions can be finish quick,they are executed by the interrupt handler immediately, with the interrupts ENABLED
Noncritical deferrable:eg copying a buffers contents into the address space of some process.
performed by means of Bhs
All interrupt handlers perform the same four basic actions: 
1.Save the IRQ value and the registers contents in the Kernel Mode stack. 
2.Send an ack to the PIC that is servicing the IRQ line, thus allowing it to issue further interrupts. 
3.Execute the interrupt service routines (ISRs) associated with all the devices that share the IRQ. 
4.Terminate by jumping to the ret_from_intr( ) address. 
Figure 4-3. Interrupt handling h/w and functions that handle the intrpt

4.6.1 Interrupt Vectors 
the 16 physical IRQs are assigned the vectors 32-47.For IRQs, the kernel must establish a correspondence between IRQ number and I/O device before enabling interrupts. Otherwise,
how could the kernel handle a signal from (say) a SCSI disk without knowing which vector corresponds to the device? 
There are two ways to select a line for each device: 
•By a utility program executed when installing the device: the user to select an available IRQ number or determine an available number by itself. 
•By a hardware protocol executed at system startup.peripheral devices declare which interrupt lines they are ready to use; the final values are then negotiated to reduce conflicts as much as possible. Once this is done, each interrupt handler can read the assigned IRQ by using a function that accesses some I/O ports of the device. For instance, drivers for devices that comply with the Peripheral Component Interconnect (PCI) standard makeuse of a group of functions such as pci_read_config_byte( ) and  pci_write_config_byte( ) to access the device configuration space.
Table 4-2. An Example of IRQ Assignment to I/O Devices  
Figure 4-4
relationships between the main descriptors that represent the state of the IRQ lines.  Except Bhs
4.6.2.1 The irq_desc_t descriptor 
An irq _desc array includes NR_IRQS irq _desc_t descriptors, which include the following 
fields: 
status A set of flags describing the IRQ line status. 
IRQ _INPROGRESS A handler for the IRQ is being executed. 
IRQ _DISABLED The IRQ line has been deliberately disabled by a device driver. 
IRQ _PENDING IRQ has occurred on the line; its occurrence has been acknowledged to the PIC, 
but it has not yet been serviced by the kernel. 
IRQ _REPLAY The IRQ line has been disabled but the previous IRQ occurrence has not yet been 
acknowledged to the PIC. 
IRQ _AUTODETECT The kernel is using the IRQ line whileperforming a hardware device probe. 
IRQ _WAITING The kernel is using the IRQ line while performing a hardware device probe; moreover, the corresponding interrupt has not been raised. 

Handler Points to the  hw_interrupt_type descriptor that identifies the PIC servicing the IRQ line. 

Action :interrupt service routines to be invoked when the IRQ occurs. The field points to the first element of the list of  irqaction descriptors associated with the IRQ.
Depth :0 if the IRQ line is enabled and +ve if it has been disabled at least once. Every time the disable_irq( ) function increments it enable_irq( ) function decrements the field.

During system initialization, the init_IRQ( ) function sets the status field of each IRQ  main descriptor to  IRQ _DISABLED
as follows: 
for (i=0; i<NR_IRQS; i++) 
	irq_desc[i].status = IRQ_DISABLED; 

It then updates the IDT by replacing the provisional interrupt gates with the final ones. This is 
accomplished through the following statements: 
for (i = 0; i < NR_IRQS; i++) 
set_intr_gate(0x20+i,interrupt[i]); 
This code looks in the interrupt array to find the interrupt handler addresses that it uses to set up the interrupt gates. The interrupt handler for IRQn is named IRQn_interrupt( )

4.6.2.2 The hw_interrupt_type descriptor 
This descriptor includes a group of pointers to the low-level I/O routines that interact with a specific PIC circuit. Linux supports 8259A  SMP IO-APIC, PIIX4's internal 8259 PIC, and SGI's Visual Workstation Cobalt (IO-)APIC. we'll assume two 8259A PICs, which provides the 16 standard IRQs. In this case, the handler in each of the 16 irq _desc_t descriptors points to the i8259A_irq _type variable. This variable is initialized as follows: 
struct hw_interrupt_type i8259A_irq_type = { 
"XT-PIC", 		//The first field in this structure,  "XT-PIC" , is a name. Following that, 
startup_8259A_irq, //pointers to five different functions used to program the PIC. 
shutdown_8259A_irq, // two functions  start up and shut down an IRQ line  of the chip,respectively. 
do_8259A_IRQ, 
enable_8259A_irq, //for 8259A chip  these functions coincide with the last two functions
disable_8259A_irq //, which enable and disable the line. 
}; 

4.6.2.3 The irqaction descriptor 
As described earlier, multiple devices can share a single IRQ. Therefore, the kernel maintains 
irqaction descriptors, each of which refers to a specific hardware device and a specific interrupt. The descriptor includes the following fields. 
Handler :Points to the interrupt service routine for an I/O device. 
Flags:Describes the relationships between IRQ line and I/O device in a set of flags: 
SA_INTERRUPT The handler must execute with interrupts disabled. 
SA_SHIRQ The device permits its IRQ line to be shared with other devices. 
SA_SAMPLE_RANDOM consider it source of events occurring randomly; and use it in kernel random number generator.( /dev/randomand /dev/urandomdevice files.) 
SA_PROBE The kernel is using the IRQ line while performing a hardware device probe. 
Name Names of the I/O device (names in /proc/interrupts file come from here). 
dev_id The major and minor numbers that identify the I/O device 
next Points to the next element of list of irqaction.refer to hardware devices that share the same IRQ

4.6.3 Saving the Registers 
Saving registers is the first task of the interrupt handler. handler for IRQn is IRQn_interrupt, and its address is included in the interrupt gate stored in the proper IDT entry. 
The same  BUILD_IRQ macro is duplicated 16 times, once for each IRQ number, in order to 
yield 16 different interrupt handler entry points. 
BUILD_IRQ assembly language fragment: 
IRQn_interrupt: 
pushl $n-256 //to save on the stack the IRQ number associated with the interrupt minus 256
jmp common_interrupt //same code for all interrupt handlers can be executed referring to this no. 
Subtracting 256 from an IRQ no yields a -ve as +ve nos are reserved to identify system calls 
The common code can be found in the BUILD_COMMON_IRQ macro, which expands to : common_interrupt: 
SAVE_ALL //save all regs and loads the selector of the kernel data segment into ds and es. 
call do_IRQ //invoke do_IRQ fnctn
jmp ret_from_intr //jump to ret_from_intr address
SAVE_ALL expands to the following fragment: 
cld 
push %es //saves all the CPU registers that may be used by the interrupt handler on the stack, 
push %ds //except for eflags, cs, eip, ss, and esp
pushl %eax //, which are already saved automatically by the control unit 
pushl %ebp;pushl %edi ;pushl %esi ;pushl %edx ;pushl %ecx ;pushl %ebx 
movl $__KERNEL_DS,%edx //then loads the selector of the kernel data segment into ds and es
mov %dx,%ds 
mov %dx,%es 

4.6.4 The do_IRQ( ) Function
 do_IRQ( ) is invoked to execute all ISRs associated with an interrupt. When it starts, the kernel stack contains from the top down: 
•The do_IRQ( ) return address 
•The group of register values pushed on by SAVE_ALL
•The encoding of the IRQ number (n-255)
•The registers saved automatically by the control unit when it recognized the interrupt 

Since the C compiler places all the parameters on top of the stack, the do_IRQ( ) function is 
declared as follows: void do_IRQ(struct pt_regs regs) 
where the pt_regs structure consists of 15 fields: 
•The first nine fields correspond to the register values pushed by SAVE_ALL
•The tenth field, referenced through a field called orig_eax, encodes the IRQ number. 
•The remaining fields correspond to the register values pushed on automatically by the CU.
The ret_from_intr( ) return address is missing because the C compiler expects a return address on top of the stack and takes this into account when generating the instructions to address parameters. 

do_IRQ( ) can read the IRQ passed and decode it as follows: irq = regs.orig_eax & 0xff; 
The function then executes:  irq_desc[irq].handler->handle(irq, &regs); 
The handler field points to the hw_interrupt_type descriptor that refers to the PIC model servicing the IRQ line.Assuming that the PIC is an 8259A, the handle field points to the do_8259A_IRQ( )
function, which is thus executed. 
The do_8259A_IRQ( ) starts by invoking mask_and_ack_8259A( ), which acknowledges the interrupt to the PIC and disables further interrupts with the same IRQ number. 
Then the the handler checks IRQ_DISABLED and IRQ_INPROGRESS stored in the status field of IRQ descriptor. If both are cleared, the function picks up the pointer to the first irqaction descriptor from the action field and sets the IRQ _INPROGRESS flag. It then invokes handle_IRQ _event( ), which  executes interrupt service for each device on that IRQ as below:
do { 
action->handler(irq, action->dev_id, regs); 
action = action->next; 
} while (action); 
Notice that the kernel cannot break the loop as soon as one ISR has claimed the interrupt because another device on the same IRQ line might need to be serviced. 
do_8259A_IRQ( ) cleans things up clearing the IRQ_INPROGRESS and if IRQ _DISABLED flag is not set, the function invokes the low-level enable_8259A_irq( ).The control returns to do_IRQ( ) , which checks whether BH tasks are  waiting to be executed.If bottom halves are waiting, the function invokes the do_bottom_half( )function . Finally, do_IRQ( ) terminates and control is transferred to the ret_from_intr address. 

