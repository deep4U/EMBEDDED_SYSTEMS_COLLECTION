interrupts are divided into 
•Synchronous produced by the CPU control unit while executing instructions
The control unit issues them only after terminating the execution of an instruction.
•Asynchronous generated by other hardware devices at arbitrary times with respect to the CPU clock signals. 
Intel 80x86 manuals call synchronous and asynchronous interrupts as exceptions and interrupts

Interrupts(sync) raised by interval timers and I/O devices;
ex the arrival of a keystroke from a user sets off an interrupt. 

Exceptions(async) are caused either by programming errors or by anomalous conditions that must be handled by the kernel.
Programming errors:the kernel handles by delivering to the current process one of the signals familiar to every Unix programmer.
Anomalous conditions:the kernel performs all the steps needed to recover from the anomalous condition, such as a page fault or a request (via an int instruction) for a kernel service.

The Role of Interrupt Signals
When an interrupt occurs,the CPU must stop what it's doing and switch to new activity;by saving the current value of the PC (eip & cs reg) in the Kernel Mode stack and by placing an address related to the interrupt type into the PC. 

there is difference between interrupt handling and process switching: the code executed by an interrupt is not a process but a kernel control path that runs on context of the process that was running when the interrupt occurred.Interrupt handler is lighter than a process (it has less context and requires less time to set up or tear down). 

Interrupt Hnadling must satisfy satisfy the following constraints:

1 Making interrupts short and real time (BH and TH)
Interrupts can come at any time Thus kernel needs to get the interrupt out of the way as soon as possible and defer as much processing as it can.(To BHs)

For eg,A block of data arrived on a network line.
The hardware interrupts the kernel
it simply marks the presence of data
gives the processor back to whatever was running before
Does rest of the processing(like moving the data into a buffer where its recipient process can find it and restarting the proces)later.
Activities that are needed to be performed for interrupt are divided in:
a top half that the kernel executes right away 
and a bottom half that is left for later.
A queue pointing to all BHs waiting to be executed kernel pulls them off the queue to execute them at particular points in processing.

2 Nestablility in interrupt kernel control paths

Interrupts can come at any time, the kernel might be handling one of them while 
another(of diff type)occurs. This should be allowed as keeps the I/O devices busy.
The interrupt handlers must be coded so that the corresponding kernel control 
paths can be executed in a nested manner.
When the last kernel control path terminates, the kernel must be able to resume execution of the interrupted process or switch to another process if the interrupt signal has caused a rescheduling activity. 

3 Limited use of critical regions requiring interrupts to be disabled
Although the kernel may accept a new interrupt signal while handling a previous one some critical regoins may disable interrupts
in particular the interrupt handlers, should run most of the time with the interrupts enabled

Classification

Interrupts:
1 Maskable : Sent to INTR pin.They can be disabled by clearing the IF flag of the eflags register.eg IRQs issued by I/O devices
2 Nonmaskable :Sent to the NMI pin.Only a few critical events,eg hardware failures, give rise to them.

Exceptions:

1 Processor-detected exceptions (Faults , traps and Aborts)
Generated on CPU finding anomalous condition while executing an instruction. divided into three groups,depending on the value of the eip saved on the Kernel Mode stack when control unit raises them 
 	a Faults
eip is the address of the instruction that caused the fault, and same instruction can be resumed when the exception handler terminates. whenever the handler is able to correct the anomalous condition that caused the exception. 
	b Traps
eip is the address of the instruction that should be executed after the one that caused the trap. A trap is triggered only when there is no need to reexecute the instruction that terminated.
use of traps is for debugging purposes:eg to notify the debugger that a specific instruction has been executed (eg breakpoint has been reached within a program). Once the user has examined the data provided by the debugger,execution of the debugged program resume starting from the next instruction. 
	c Aborts
A serious error; the control unit is in trouble,and it may be unable to store a 
meaningful value in the eip.May be caused by hardware failures or by 
invalid values in system tables. The inte rrupt signal sent by the control unit is an emergency signal used to switch control to the corresponding abort exception handler. This handler has no choice but to force the affected process to terminate.

2 Programmed exceptions
Occur at the request of the programmer.Triggered by: 1)int or int3 instructions; 2)the into (check for overflow) and bound (check on address bound) instructions when the condition they are checking is not true.
Programmed exceptions are handled by the control unit as traps; they are often called software interrupts. Such exceptions have two common uses: to implement system calls, and to notify a debugger of a specific event

Interrupt / Exception vectores

Each intr or excptn has a 8bit unsigned identifier from 0 to 255 called vector
For nonmaskable interrupts and exceptions are fixed
for maskable interrupts can be altered by programming Interrupt Controller

Linux uses the following vectors: 
•0 to 31 : exceptions and nonmaskable interrupts. 
•32 to 47: maskable interrupts, that is, to interrupts caused by IRQs. 
•remaining from 48 to 255 may be used to identify software interrupts.Linux uses one of them, namely the 128 or 0x80 vector to implement system calls. When an int 0x80 Assembly instruction is executed by a process in User Mode, the CPU switches into Kernel Mode and starts executing the system_call( ) kernel function


IRQ and Interrupts

Each hw device controller capable of issuing interrupt requests has an op line designated as an IRQ (Interrupt ReQuest).All IRQ lines are connected to the input pins of a hardware circuit called the Interrupt Controller, which performs the following actions: 
1.Monitors the IRQ lines, checking for raised signals. 
2.If a raised signal occurs on an IRQ line: 
a.Converts the raised signal into a corresponding vector. 
b.Store vector in an Itr Contrlr I/O port so thatCPU can read it via the data bus.
c.Sends a raised signal to the processor INTR pin—that is, issues an interrupt.
d.Waits until the CPU acks the intr signal by writing into one of 
the Programmable Interrupt Controllers (PIC) I/O ports;when wait ends clears the INTR line.
3.Goes back to step 1. 
The IRQ lines are sequentially numbered starting from 0; thus, the first IRQ line is denoted as IRQ0. Intel's default vector with IRQn is n+32
the mapping between IRQs and vectors can be modified by issuing suitable I/O instructions to the Interrupt Controller ports. 
Figure 4-1 illustrates a typical connection "in cascade" of two Intel 8259A PICs that can handle up to 15 different IRQ input lines.
Other lines not shown in the figure connect the PICs to the bus: in particular, bidirectional lines D0-D7 connect the I/O port to the data bus, while
another input line is connected to the control bus and is used for receiving acknowledgment signals from the CPU. 
Since the number of available IRQ lines is limited, it may be necessary to share the same line among several different I/O devices. When this occurs, all the devices connected to the same line will have to be polled sequentially by the software interrupt handler in order to determine which of them has issued an interrupt request.

FIGURE 4-1

Each IRQ line can be selectively disabled. Thus, the PIC can be programmed to disable IRQs. Disabled interrupts are not lost; the PIC sends them to the CPU as soon as they are enabled again. This feature is used by most interrupt handlers, since it allows them to process IRQs of the same type serially.Selective enabling/disabling of IRQs is not the same as global masking/unmasking of maskable interrupts. When the IF flag of the eflags register is clear, any maskable interrupt issued by the PIC is simply ignored by the CPU. The cli and sti Assembly instructions, respectively, clear and set that flag. 

Exceptions The Intel 80x86 microprocessors issue roughly 20 different exceptions.the CPU control unit also generates a hardware error code and pushes it in the Kernel Mode stack before starting the exception handler. 
The following list gives the vector, the name, the type, and a brief description of the exceptions found in a Pentium model.


0 - "Divide error" (fault) Raised when a program tries to divide by 0.
1- "Debug" (trap or fault) Raised when the T flag of eflags is set (quite useful to implement step-by-step execution of a debugged program) or when the address of an instruction or operand falls within the range of an active debug register
2 - Not used Reserved for nonmaskable interrupt
3 - "Breakpoint" (trap) Caused by an int3 (breakpoint) instruction (usually inserted by a debugger). 
4 - "Overflow" (trap) An into (check for overflow) instruction has been executed when the OF (overflow) flag of eflags is set. 
5 - "Bounds check" (fault) A bound (check on address bound) instruction has been executed with the operand outside of the valid address bounds. 
6 - "Invalid opcode" (fault) The CPU execution unit has detected an invl opcode
7 - "Device not available" (fault) An ESCAPE or MMX instruction has been executed with the TS flag of cr0 set 
8 - "Double fault" (abort) Normally, when the CPU detects an exception while trying to call the handler for a prior exception, the two exceptions can be handled serially. In a few cases, however, the processor cannot handle them serially, hence it raises this exception. 
9 - "Coprocessor segment overrun" (abort) Problems with the external mathematical coprocessor (applies only to old 80386 microprocessors). 
10 - "Invalid TSS" (fault) The CPU has attempted a context switch to a process having an invalid Task State Segment. 
11 - "Segment not present" (fault) A reference was made to a segment not present in memory (Segment-Present flag of Segment Descriptor was cleared). 
12 - "Stack segment" (fault) The instruction attempted to exceed the stack segment limit, or the segment identified by ss is not present in memory. 
13 - "General protection" (fault)One of the protection rules in the protected mode of the Intel 80x86 has been violated. 
14 - "Page fault" (fault) The addressed page is not present in memory, the corresponding page table entry is null, or a violation of the paging protection mechanism has occurred. 
15 - Reserved by Intel
16 - "Floating point error" (fault)The floating point unit integrated into the CPU chip has signaled an error condition, such as numeric overflow or division by 0. 
17 - "Alignment check" (fault)The address of an operand is not correctly aligned (for instance, the address of a long integer is not a multiple of 4). 
18 to 31 These values are reserved by Intel for future development. 

Table 4-1

4.2.4 Interrupt Descriptor Table 
System table Interrupt Descriptor Table (IDT) associates each interrupt or exception vector with the address of the corresponding interrupt or exception handler. The IDT must be properly initialized before the kernel enables interrupts. format similar GDT and of the LDTs: each entry corresponds to an in terrupt or an exception vector and consists of an 8-byte descriptor. Thus, a maximum of 256x 8=2048 bytes 
The idtr CPU register allows the IDT to be located anywhere in memory:both the IDT base physical address and its limit (maximum length). It must be initialized before enabling interrupts by using the lidt assembly language instruction. The IDT may include three types of descriptors; Figure 4-2 illustrates the meaning of the 64 bits included in each of them.Type field bits 40-43 identifies the descriptor type. 

Figure 4-2

Task gate Includes the TSS selector of the process that must replace the current one when an interrupt signal occurs. Linux does not use task gates. 
Interrupt gate Includes the Segment Selector and the offset inside the segment of an interrupt or exception handler. While transferring control to the proper segment, the processor clears the IF flag, thus disabling further maskable interrupts. 
Trap gate Similar to an interrupt gate, except that while transferring control to the proper segment, the processor does not modify the IF flag. 
Linux uses interrupt gates to handle interrupts and trap gates to handle exceptions. 

4.2.5 Hardware Handling of Interrupts and Exceptions 

how the CPU control unit handles interrupts and exceptions. We assume that the kernel has been initialized and thus the CPU is operating in protected mode. After executing an instruction, the cs and eip pair of registers contain the logical address of the next instruction to be executed. Before dealing with that instruction, the control unit checks whether an interrupt or an exception has occurred while it executed the previous instruction. If one occurred, the control unit: 
1.Determines the vector i associated with the interrupt or the exception. 
2.Reads the i th entry of the IDT referred by the idtr register (we assume the entry contains an interrupt or a trap gate). 
3.Gets the base address of the GDT from gdtr and looks in the GDT to read Segment Descriptor identified by the selector in the IDT entry. This descriptor specifies the base address of the segment that includes the interrupt or exception handler. 
4.Makes sure the interrupt was issued by an authorized source. First compares the Current Privilege Level (CPL), which is stored in the two LSBs of cs, with the Descriptor Privilege Level (DPL) of the Segment Descriptor included in the GDT. Raises a "General protection" exception if CPL is lower than DPL, because the interrupt handler cannot have a lower privilege (more PL value)than the program that caused the interrupt. For programmed exceptions, makes a further security check: compares the CPL with the DPL of the gate descriptor included in the IDT and raises a "General protection" exception if the DPL is lower than the CPL. This last check makes it possible to prevent access by user applications to specific trap or interrupt gates. 
5.Checks whether a change of privilege level is taking place, that is, if CPL is different from the selected Segment Descriptor's DPL. If so, the control unit must start using the stack that is associated with the new privilege level. It does this by performing the following steps: 
a.Reads the tr register to access the TSS segment of the current process. 
b.Loads the ss and esp registers with the proper values for the stack segment and stack pointer relative to the new privilege level. These values are found in the TSS
c.In the new stack, saves the previous values of ss and esp, which define the logical address of the stack associated with the old privilege level. 
6.If a fault has occurred, loads cs and eip with the logical address of the instruction that caused the exception so that it can be executed again. 
7.Saves the contents of eflags, cs, and eip in the stack. 
8.If the exception carries a hardware error code, saves it on the stack. 
9.Loads cs and eip, respectively, with the Segment Selector and the Offset fields of the Gate Descriptor stored in the i th entry of the IDT. Thesevalues define the logical address of the first instruction of the interrupt or exception handler. The last step performed by the control unit isequivalent to a jump to the interrupt or exception handler.

In other words, the instruction processed by the control unit after dealing with theinterrupt signal is the first instruction of the selected handler. After the interrupt or exception has been processed, the corresponding handlermust relinquish control to the interrupted process by issuing the iret
 instruction, which forces the cu to:

1.Load the cs, eip, and eflags registers with the values saved on the stack. If a hw err code has been pushed in the stack on top of the eip contents, it must be popped before executing iret. 
2.Check whether the CPL of the handler is equal to the value contained in the two least significant bits of cs If so, iret concludes execution; otherwise, go to the next step. 
3.Load the ss and esp registers from the stack, and hence return to the stack associated with the old privilege level. 
4.Examine the contents of the ds, es, fs, and gs segment registers: if any of them contains a selector that refers to a Segment Descriptor whose DPL value is lower than CPL, clear the corresponding segment register. The control unit does this to forbid User Mode programs that run with a CPL equal to 3 from making use of segment registers previously used by kernel routines (with a DPL equal to 0). If these registers were not cleared, malicious User Mode programs could exploit them to access the kernel address space

4.3 Nested Execution of Exception and Interrupt Handlers 
A kernel control path consists of the sequence of instructions executed in Kernel Mode to handle an interrupt or an exception. When a process issues a system call request, for instance, the first instructions of the corresponding kernel control path are those that save the content of the registers in the Kernel Mode stack, while the last instructions are those that restore the content of the registers and put the CPU back into User Mode. 

Assuming that the kernel is bug-free, most exceptions can occur only while the CPU is in User Mode. Indeed, they are either caused by programming errors or triggered by debuggers. However, the "Page fault" exception may occur in Kernel Mode.While handling such an exception, the kernel may suspend the current process and replace it with another one until the requested page is available.The kernel control path that handles the page fault exception will resume execution as soon as the process gets the processor again. Since the "Page fault" exception handler never gives rise to further exceptions, at most two kernel control paths associated with exceptions may be stacked, one on top of the other. 
In contrast to exceptions, interrupts issued by I/O devices do not refer to data structures specific to the current process, although the kernel control paths that handle them run on behalf of that process. As a matter of fact, it is impossible to predict which process will be currently running when a given interrupt occurs. Linux design does not allow process switching while the CPU is executing a kernel control path associated with an interrupt. However, such kernelcontrol paths may be arbitrarily nested: an interrupt handler may be interrupted by another interrupt handler and so on. An interrupt handler may also defer an exception handler. Conversely, an exception handler never defers an interrupt handler. The only exception that can be triggered in Kernel Mode is the "Page fault" one just described. But interrupt handlers never perform operations that could induce page faults and thus, potentially, process switching. 
Linux interleaves kernel control paths for two major reasons:
•To improve the throughput of programmable interrupt controllers and device controllers. Assume that a device controller issues a signal on an IRQ line:thePIC transforms it into an INTR request, and then both the PIC and the device controller remain blocked until the PIC receives an acknowledgment from the CPU. Thanks to kernel control path interleaving, the kernel is able to send the acknowledgment even when it is handling a previous interrupt. 
•To implement an interrupt model without priority levels. Since each interrupt handler may be deferred by another one, there is no need to establishpredefined priorities among hardware devices. This simplifies the kernel code and improves its portability

4.4 Initializing the Interrupt Descriptor Table 
The int instruction allows a User Mode process to issue an interrupt signal having an arbitrary vector ranging from to 255. The initialization of the IDT must thus be done carefully, in order to block illegal interrupts and exceptions simulated by User Mode processes via int instructions. This can be
 achieved by setting the DPL field of the Interrupt or Trap Gate Descriptor to 0. In a few cases, however, a User Mode process must be able to issue a programmed exception. To allow this, it is sufficient to set the DPL field of the corresponding Interrupt or Trap Gate Descriptors to 3;

Interrupt gate :An Intel intr gate that cannot be accessed by a User Mode process (the gate's DPL field is equal to 0). All Linux intr handlers are activated by means of interrupt gates, and all are restricted to Kernel Mode. 
System gate:An Intel trap gate that can be accessed by a User Mode process (the gate's DPL field is equal to 3). The four Linux exception handlers associated with the vectors 3, 4, 5, and 128 are activated by means of system gates, so the four Assembly instructions int3, into, bound, and int 0x80 can be issued in User Mode. 
Trap gate:An Intel trap gate that cannot be accessed by a User Mode process (the gate's DPL field is equal to 0). All Linux exception handlers, except the four described in the previous paragraph, are activated by means of trap gates. 

The following functions are used to insert gates in the IDT: 
set_intr_gate(n,addr)
Inserts an interrupt gate in the nth IDT entry. The Segment Selector inside the gate is set to the kernel code's Segment Selector. The Offset field is set to addr, which is the address of the interrupt handler. The DPL field is set to 0. 
set_system_gate(n,addr)
Same exceppt trap gate and The DPL field is set to 3. 
set_trap_gate(n,addr)
Similar to the previous function, except that the DPL field is set to 0
